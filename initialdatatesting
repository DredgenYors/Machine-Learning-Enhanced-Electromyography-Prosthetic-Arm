import scipy.io
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt
from tkinter import Tk
from tkinter.filedialog import askopenfilename
from scipy.stats import mode
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import scipy.io
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import butter, filtfilt
from tkinter import Tk
from tkinter.filedialog import askopenfilename
from scipy.stats import mode
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

# -------------------------------
# 1. Run Python file and choose Matlab file when prompted
# 2. Let the code run and view the plots and confusion matrix generated afterwards
# -------------------------------
# -------------------------------
# 1. Prompt user to select a MATLAB file
# -------------------------------
Tk().withdraw()  # hide the root Tk window
mat_file = askopenfilename(title="Select a MATLAB .mat file",
                           filetypes=[("MAT files", "*.mat")])

if not mat_file:
    raise ValueError("No file selected. Exiting.")

print(f"Selected file: {mat_file}")

# -------------------------------
# 2. Load MATLAB file
# -------------------------------
mat = scipy.io.loadmat(mat_file)
emg = np.squeeze(mat['emg'])  # shape: (samples, channels)

# Detect numeric labels
if 'stimulus' in mat:
    stimulus = mat['stimulus']
    print("Using 'stimulus' as labels.")
else:
    raise ValueError("No per-sample labels found in .mat file.")

# -------------------------------
# 3. Check EMG shape
# -------------------------------
print("EMG shape:", emg.shape)
if emg.ndim == 1:
    num_channels = 1
    emg = emg[:, np.newaxis]
    print("Single-channel EMG")
else:
    num_channels = emg.shape[1]
    print(f"Multi-channel EMG with {num_channels} channels")

# -------------------------------
# 4. Plot raw EMG
# -------------------------------
plt.figure(figsize=(12, 6))
for ch in range(num_channels):
    plt.plot(emg[:, ch] + ch*0.5, label=f'Ch {ch}')
plt.title("Raw EMG")
plt.xlabel("Time (samples)")
plt.ylabel("Amplitude (offset)")
plt.legend()
plt.show()

# -------------------------------

# 5. Signal processing: mean removal and rectification only
# -------------------------------
emg_mean_removed = emg - np.mean(emg, axis=0)
emg_rectified = np.abs(emg_mean_removed)


# 6. Plot raw, mean-removed, and rectified EMG side by side
# -------------------------------
plt.figure(figsize=(18, 6))

# Plot raw EMG
plt.subplot(1, 3, 1)
for ch in range(num_channels):
    plt.plot(emg[:, ch] + ch*0.5, label=f'Ch {ch}')
plt.title("Raw EMG")
plt.xlabel("Time (samples)")
plt.ylabel("Amplitude (offset)")
plt.legend()

# Plot mean-removed EMG
plt.subplot(1, 3, 2)
for ch in range(num_channels):
    plt.plot(emg_mean_removed[:, ch] + ch*0.5, label=f'Ch {ch}')
plt.title("Mean Removed EMG")
plt.xlabel("Time (samples)")
plt.ylabel("Amplitude (offset)")
plt.legend()

# Plot rectified EMG
plt.subplot(1, 3, 3)
for ch in range(num_channels):
    plt.plot(emg_rectified[:, ch] + ch*0.5, label=f'Ch {ch}')
plt.title("Rectified EMG")
plt.xlabel("Time (samples)")
plt.ylabel("Amplitude (offset)")
plt.legend()

plt.tight_layout()
plt.show()

# -------------------------------
# 7. Butterworth low-pass filters at 2, 5, 10, 20 Hz and plot for comparison
# -------------------------------
def lowpass_filter(signal, fs, cutoff, order=4):
    nyq = 0.5 * fs
    normal_cutoff = cutoff / nyq
    b, a = butter(order, normal_cutoff, btype='low')
    return filtfilt(b, a, signal, axis=0)

# Set your sampling frequency (adjust if needed)
fs = 1000

# Apply low-pass filters with different cutoffs to the rectified EMG
emg_lp_2hz = lowpass_filter(emg_rectified, fs, 2)
emg_lp_5hz = lowpass_filter(emg_rectified, fs, 5)
emg_lp_10hz = lowpass_filter(emg_rectified, fs, 10)
emg_lp_20hz = lowpass_filter(emg_rectified, fs, 20)


# Plot raw rectified and all four filtered results for all channels side by side
plot_len = 2000  # Number of samples to plot
fig, axes = plt.subplots(nrows=1, ncols=5, figsize=(22, 10), sharey=True)

# Raw rectified
for ch in range(num_channels):
    axes[0].plot(emg_rectified[:plot_len, ch] + ch*0.5, label=f'Ch {ch}')
axes[0].set_title('Raw Rectified')
axes[0].set_xlabel('Time (samples)')
axes[0].set_ylabel('Amplitude (offset)')
axes[0].legend()

# 2 Hz
for ch in range(num_channels):
    axes[1].plot(emg_lp_2hz[:plot_len, ch] + ch*0.5, label=f'Ch {ch}')
axes[1].set_title('2 Hz LPF')
axes[1].set_xlabel('Time (samples)')
axes[1].legend()

# 5 Hz
for ch in range(num_channels):
    axes[2].plot(emg_lp_5hz[:plot_len, ch] + ch*0.5, label=f'Ch {ch}')
axes[2].set_title('5 Hz LPF')
axes[2].set_xlabel('Time (samples)')
axes[2].legend()

# 10 Hz
for ch in range(num_channels):
    axes[3].plot(emg_lp_10hz[:plot_len, ch] + ch*0.5, label=f'Ch {ch}')
axes[3].set_title('10 Hz LPF')
axes[3].set_xlabel('Time (samples)')
axes[3].legend()

# 20 Hz
for ch in range(num_channels):
    axes[4].plot(emg_lp_20hz[:plot_len, ch] + ch*0.5, label=f'Ch {ch}')
axes[4].set_title('20 Hz LPF')
axes[4].set_xlabel('Time (samples)')
axes[4].legend()

plt.tight_layout()
plt.show()

print("Mean of each channel:", np.mean(emg, axis=0))
print("Min of each channel:", np.min(emg, axis=0))

# ...existing code...

# Split into train and test sets (80% train, 20% test)
# X_train, X_test, y_train, y_test = train_test_split(
#    feature_matrix, window_labels, test_size=0.2, random_state=42, stratify=window_labels
#)
#print("Training samples:", X_train.shape[0])
#print("Test samples:", X_test.shape[0])

# Initialize classifier
#clf = RandomForestClassifier(n_estimators=100, random_state=42)

# Train
#clf.fit(X_train, y_train)

#y_pred = clf.predict(X_test)

# Accuracy
#acc = accuracy_score(y_test, y_pred)
#print("Test Accuracy:", acc)

# Detailed classification report
#print("\nClassification Report:\n", classification_report(y_test, y_pred))

# Confusion matrix
#cm = confusion_matrix(y_test, y_pred)
#print("\nConfusion Matrix:\n", cm)

#import matplotlib.pyplot as plt
#import seaborn as sns

#plt.figure(figsize=(12, 10))
#sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
#plt.xlabel("Predicted Label")
#plt.ylabel("True Label")
#plt.title("Confusion Matrix")
#plt.show()
